{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Profil Penulis \u00b6 Nama : Faridz Nur Firdausy Setyo Nugraha NIM : 190411100084 Program Studi : Teknik Informatika Kelas : Komputasi Numerik 4B Dosen Pengampu : Mula'ab, S.Si., M.Kom.","title":"Profil"},{"location":"#profil_penulis","text":"Nama : Faridz Nur Firdausy Setyo Nugraha NIM : 190411100084 Program Studi : Teknik Informatika Kelas : Komputasi Numerik 4B Dosen Pengampu : Mula'ab, S.Si., M.Kom.","title":"Profil Penulis"},{"location":"index1/","text":"INTEGRASI NUMERIK \u00b6 Integrasi numerik merupakan cara untuk menghitung nilai numerik atau luas nilai dari suatu fungsi integral yang terdapat batas luas yang sudah diberikan pada fungsi. jenis-jenis integral \u00b6 integral tak tentu ialah fungsi integral yang tidak memiliki nilai penentunya sehingga fungsi hanya dapat integrasi fungsinya tanpa mendapat nilai hasil integral. \\[ \\int xdx=\\dfrac{x^{2}}{2}+c \\] integral tentu ialah fungsi integral yang terdapat nilai tentunya sehingga dapat ditentukan nilai integrasinya. \\[ \\int ^{1}_{0}xdx=\\dfrac{2x}{2} |^{1}_{0}=\\dfrac{2}{2}=1 \\] Metode Rekursif Trapezoid \u00b6 merupakan sebuah metode untuk mendapatan nilai dari integrasi tentu dengan beberapa aturan yang telah ada. Membuat permisalan f merupakan sebuah fungsi yang memiliki definisi [a,b] dan h = (b-a), untuk n = 1, 2, 4, 8, .... atau n= \\(2^0\\) , \\(2^1\\) , \\(2^2\\) , \\(2^3\\) , ...., kita mendefinisikan barisan aturan trapezoid \\[ T0,T_{1},T_{2},T_{3},\\ldots ,T_{k},\\ldots . \\] \u200b dengan T_{0}=T_{1}\\left( f,h\\right) =\\dfrac{h}{2}\\left( f\\left( a\\right) +f\\left( b\\right) \\right) dan T_{k}=T_{2^k}\\left( f,\\dfrac{h}{2^{k}}\\right) ,k=1,2,3,\\ldots \u200b Barisan trapezoid tersebut dapat memenuhi hubungan T_{k+1}=\\dfrac{T_{k}}{2}+\\dfrac{h}{2^{k+1}}\\sum ^{2^k}_{j=1}f_{2j-1} dengan f_{i}=f\\left( a+i\\dfrac{h}{2^{k+1}}\\right) setelah memenuhi hubungan kita bisa memulai perhitungan rekursif trapezoid \\begin{aligned}h=b-a\\\\ T_{0}=\\dfrac{h}{2}\\left( f\\left( a\\right) +f\\left( b\\right) \\right) \\\\ T_{1}=\\dfrac{T_{0}}{2}+\\dfrac{h}{2}f_{1}\\\\ T_{2}=\\dfrac{T_{1}}{2}+\\dfrac{h}{4}\\left( f_{1}+f_{2}\\right) \\\\ T_{3}=\\dfrac{T_{2}}{2}+\\dfrac{h}{8}\\left( f_{1}+f_{3}+f_{5}+f_{7}\\right) \\end{aligned} Kode python metode Rekursif Trapezoid \u00b6 program python : # fungsi x^2 def trapezoid ( a , b , Iold , k ): if k == 1 : Inew = ( a ** 2 ) + ( b ** 2 ) * ( b - a ) / 2.0 else : n = 2 ** ( k - 2 ) h = ( b - a ) / n x = a + h / 2.0 hasil = 0.0 for i in range ( n ): hasil = hasil + x ** 2 x = x + h Inew = ( Iold + h * hasil ) / 2.0 return Inew print ( \"hasil = \" , trapezoid ( 0 , 1 , 0 , 5 )) hasil output : hasil = 0.166015625","title":"Integrasi Numerik"},{"location":"index1/#integrasi_numerik","text":"Integrasi numerik merupakan cara untuk menghitung nilai numerik atau luas nilai dari suatu fungsi integral yang terdapat batas luas yang sudah diberikan pada fungsi.","title":"INTEGRASI NUMERIK"},{"location":"index1/#jenis-jenis_integral","text":"integral tak tentu ialah fungsi integral yang tidak memiliki nilai penentunya sehingga fungsi hanya dapat integrasi fungsinya tanpa mendapat nilai hasil integral. \\[ \\int xdx=\\dfrac{x^{2}}{2}+c \\] integral tentu ialah fungsi integral yang terdapat nilai tentunya sehingga dapat ditentukan nilai integrasinya. \\[ \\int ^{1}_{0}xdx=\\dfrac{2x}{2} |^{1}_{0}=\\dfrac{2}{2}=1 \\]","title":"jenis-jenis integral"},{"location":"index1/#metode_rekursif_trapezoid","text":"merupakan sebuah metode untuk mendapatan nilai dari integrasi tentu dengan beberapa aturan yang telah ada. Membuat permisalan f merupakan sebuah fungsi yang memiliki definisi [a,b] dan h = (b-a), untuk n = 1, 2, 4, 8, .... atau n= \\(2^0\\) , \\(2^1\\) , \\(2^2\\) , \\(2^3\\) , ...., kita mendefinisikan barisan aturan trapezoid \\[ T0,T_{1},T_{2},T_{3},\\ldots ,T_{k},\\ldots . \\] \u200b dengan T_{0}=T_{1}\\left( f,h\\right) =\\dfrac{h}{2}\\left( f\\left( a\\right) +f\\left( b\\right) \\right) dan T_{k}=T_{2^k}\\left( f,\\dfrac{h}{2^{k}}\\right) ,k=1,2,3,\\ldots \u200b Barisan trapezoid tersebut dapat memenuhi hubungan T_{k+1}=\\dfrac{T_{k}}{2}+\\dfrac{h}{2^{k+1}}\\sum ^{2^k}_{j=1}f_{2j-1} dengan f_{i}=f\\left( a+i\\dfrac{h}{2^{k+1}}\\right) setelah memenuhi hubungan kita bisa memulai perhitungan rekursif trapezoid \\begin{aligned}h=b-a\\\\ T_{0}=\\dfrac{h}{2}\\left( f\\left( a\\right) +f\\left( b\\right) \\right) \\\\ T_{1}=\\dfrac{T_{0}}{2}+\\dfrac{h}{2}f_{1}\\\\ T_{2}=\\dfrac{T_{1}}{2}+\\dfrac{h}{4}\\left( f_{1}+f_{2}\\right) \\\\ T_{3}=\\dfrac{T_{2}}{2}+\\dfrac{h}{8}\\left( f_{1}+f_{3}+f_{5}+f_{7}\\right) \\end{aligned}","title":"Metode Rekursif Trapezoid"},{"location":"index1/#kode_python_metode_rekursif_trapezoid","text":"program python : # fungsi x^2 def trapezoid ( a , b , Iold , k ): if k == 1 : Inew = ( a ** 2 ) + ( b ** 2 ) * ( b - a ) / 2.0 else : n = 2 ** ( k - 2 ) h = ( b - a ) / n x = a + h / 2.0 hasil = 0.0 for i in range ( n ): hasil = hasil + x ** 2 x = x + h Inew = ( Iold + h * hasil ) / 2.0 return Inew print ( \"hasil = \" , trapezoid ( 0 , 1 , 0 , 5 )) hasil output : hasil = 0.166015625","title":"Kode python metode Rekursif Trapezoid"},{"location":"index2/","text":"SISTEM PERSAMAAN LINEAR \u00b6 Sistem persamaan linear merupakan sebuah sistem yang menghimpun beberapa persamaan linear yang memiliki banyak variabel. Penyelesaian sistem persamaan linear ini terdapat banyak cara yaitu eliminasi Gauss, metode Jacobi, dan metode Gauss Seidel. Eliminasi Gauss \u00b6 Eliminasi Gauss merupakan sebuah metode untuk menyelesaikan suatu sistem persamaan linear dengan mengubah menjadi matrix lalu membaginya menjadi segitiga bawah dan atas, untuk segitiga bawah harus bernilai nol dengan cara operasi baris elementer agar segera mendapatkan nilai variabelnya. \\[ \\begin{bmatrix} a_{11}, & a_{12},& a_{13},&\\ldots a_{1n} \\\\ 0 , & a_{22},& a_{23},&\\ldots a_{2n}\\\\ 0 , & 0,& a_{33},&\\ldots a_{3n} \\\\ \\ldots,& \\ldots ,& \\ldots ,& \\ldots \\\\ 0,& 0 ,& 0 ,& a_{nn} \\end{bmatrix} \\begin{bmatrix}x_{1} \\\\x_{2}\\\\x_{3}\\\\\\ldots\\\\x_{n}\\end{bmatrix}= \\begin{bmatrix}b_{1} \\\\b_{2}\\\\b_{3}\\\\\\ldots\\\\b_{n}\\end{bmatrix} \\] maka penyelesaian dapat dilakukan dengan cara : \\[ \\\\x_{n}=\\dfrac{b_{n}}{a_{n,n}} \\] Kode python eliminasi Gauss \u00b6 Program Python : import numpy as np n = int ( input ( \"Berapa baris dan kolom :\" )) m = n + 1 z = np . zeros ( n ) val = [ 0 ] * n for x in range ( n ): val [ x ] = [ 0.0 ] * m for i in range ( n ): for j in range ( n + 1 ): print (( \"[ {} ][ {} ]\" ) . format ( i , j ), end = ' ' ) y = float ( input ( \"Masukkan nilai :\" )) val [ i ][ j ] = y #eliminasi maju for i in range ( n ): for j in range ( i + 1 , n ): ratio = val [ j ][ i ] / val [ i ][ i ] for k in range ( n + 1 ): val [ j ][ k ] = val [ j ][ k ] - ratio * val [ i ][ k ] #eliminasi mundur z [ n - 1 ] = val [ n - 1 ][ n ] / val [ n - 1 ][ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ): z [ i ] = val [ i ][ n ] for j in range ( i + 1 , n ): z [ i ] = z [ i ] - val [ i ][ j ] * z [ j ] z [ i ] = z [ i ] / val [ i ][ i ] print ( ' \\n hasil dari perhitungan : ' ) for i in range ( n ): print ( 'X %d = %0.2f ' % ( i , z [ i ]), end = ' \\t ' ) Hasil Output : Berapa baris dan kolom : 3 [ 0 ][ 0 ] Masukkan nilai : 3 [ 0 ][ 1 ] Masukkan nilai : 2 [ 0 ][ 2 ] Masukkan nilai : 5 [ 0 ][ 3 ] Masukkan nilai : 1 [ 1 ][ 0 ] Masukkan nilai : 2 [ 1 ][ 1 ] Masukkan nilai : 6 [ 1 ][ 2 ] Masukkan nilai : 3 [ 1 ][ 3 ] Masukkan nilai : 6 [ 2 ][ 0 ] Masukkan nilai : 3 [ 2 ][ 1 ] Masukkan nilai : 2 [ 2 ][ 2 ] Masukkan nilai : 7 [ 2 ][ 3 ] Masukkan nilai : 4 hasil dari perhitungan : X0 = - 3.00 X1 = 1.25 X2 = 1.50 Metode Jacobi \u00b6 Metode Jacobi merupakan sebuah metode untuk menemukan hasil dari sistem persamaan linear dengan cara menggunakan iterasi sebuah algoritma dan mengulangnya sampai bilangan tersebut diketemukan. Bila ada sebuah sistem persamaan linear \\[ \\\\ a_{11}x_{1}+ a_{12}x_{2}+\\ldots+ a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+ a_{22}x_{2}+\\ldots+ a_{2n}x_{n}=b_{2}\\\\ \\ldots+ \\ldots +\\ldots+\\ldots=\\ldots \\\\ a_{n1}x_{1}+ a_{n2}x_{2}+\\ldots+ a_{nn}x_{n}=b_{n} \\] persamaan ke-i dari persamaan di atas adalah \\[ a_{i1}x_{1}+ a_{i2}x_{2}+\\ldots+ a_{in}x_{n}=b_{i} \\\\dimana \\\\i = 1,2,3,\\ldots,n \\] dapat diekspresikan sebagai \\[ a_{ii}x_{i}+\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j} \\\\dengan \\\\i = 1,2,3,\\ldots,n \\] sehingga persamaan bisa terselesaikan dengan persamaan ke-i \\[ \\\\x_{i}=\\dfrac{b_{i}-\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j}}{a_{ii}} \\] dari penyelesaian tersebut dapat ditemukan sebuah algoritma metode Jacobi \\[ \\\\X_{i}^{\\left(k+1\\right) }=\\dfrac{b_{i}-\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j}^{\\left(k\\right) }}{a_{ii}},k=1,2,3,\\dots,n \\] Kode python metode Jacobi \u00b6 Program Python : import numpy as np k = 3 a = np . array ([[ 3. , 1. , - 1. ], [ 1. , 4. , 1. ], [ 1. , 2. , - 4. ]]) b = np . array ([ 6. , 8. , 9. ]) print ( \"sistem persamaan linear :\" ) for i in range ( a . shape [ 0 ]): row = [ \" {} *x {} \" . format ( a [ i , j ], j + 1 ) for j in range ( a . shape [ 1 ])] print ( \" + \" . join ( row ), \"=\" , b [ i ]) print () x = np . zeros_like ( b ) for it_count in range ( k ): print ( \"hasil sementara : \" , x ) x_new = np . zeros_like ( x ) for i in range ( a . shape [ 0 ]): s1 = np . dot ( a [ i , : i ], x [: i ]) s2 = np . dot ( a [ i , i + 1 :], x [ i + 1 :]) x_new [ i ] = ( b [ i ] - s1 - s2 ) / a [ i , i ] if np . allclose ( x , x_new , atol = 1e-10 , rtol = 0. ): break x = x_new print ( \"hasil akhir : \" , x ) error = np . dot ( a , x ) - b print ( \"error : \" , error ) Hasil Output : sistem persamaan linear : 3.0 * x1 + 1.0 * x2 + - 1.0 * x3 = 6.0 1.0 * x1 + 4.0 * x2 + 1.0 * x3 = 8.0 1.0 * x1 + 2.0 * x2 + - 4.0 * x3 = 9.0 hasil sementara : [ 0. 0. 0. ] hasil sementara : [ 2. 2. - 2.25 ] hasil sementara : [ 0.58333333 2.0625 - 0.75 ] hasil akhir : [ 1.0625 2.04166667 - 1.07291667 ] error : [ 0.30208333 0.15625 0.4375 ] Metode Gauss Seidel \u00b6 Eliminasi Gauss Seidel merupakan pengembangan metode Jacobi dengan langsung menambahkan nilai terbaru ke dalam perhitungan atau iterasi selanjutnya. Bila ada sebuah sistem persamaan linear \\[ \\\\ a_{11}x_{1}+ a_{12}x_{2}+\\ldots+ a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+ a_{22}x_{2}+\\ldots+ a_{2n}x_{n}=b_{2}\\\\ \\ldots+ \\ldots +\\ldots+\\ldots=\\ldots \\\\ a_{n1}x_{1}+ a_{n2}x_{2}+\\ldots+ a_{nn}x_{n}=b_{n} \\] persamaan ke-i dari persamaan di atas adalah \\[ a_{i1}x_{1}+ a_{i2}x_{2}+\\ldots+ a_{in}x_{n}=b_{i} \\\\dimana \\\\i = 1,2,3,\\ldots,n \\] dapat diekspresikan sebagai \\[ a_{ii}x_{i}+\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j} \\\\dengan \\\\i = 1,2,3,\\ldots,n \\] sebab dalam metode Gauss Seidel langsung menambahkan nilai terbaru maka persamaan ke-i dapat terselesaikan dengan cara \\[ \\\\x_{i}=\\dfrac{b_{i}- \\sum ^{i-1}_{j=1}a_{ij}x_{j}- \\sum ^{n}_{j=i+1}a_{ij}x_{j}}{a_{ii}} \\] dari penyelesaian tersebut dapat ditemukan sebuah algoritma metode Gauss Seidel \\[ \\\\x_{i}^{(k+1)}=\\dfrac{b_{i}- \\sum ^{i-1}_{j=1}a_{ij}x_{j}^{(k+1)}- \\sum ^{n}_{j=i+1}a_{ij}x_{j}^{(k)}}{a_{ii}}, \\\\k=1,2,3,\\ldots,n \\] nilai pendekatan iterasi ke-0 pada metode ini biasanya belum diketahui maka biasanya dapat ditentukan dengan \\[ X_{0}=0 \\] Kode python metode Gauss Seidel \u00b6 Program Python : import numpy as np from scipy.linalg import solve def gauss ( a , b , x , n ): L = np . tril ( a ) U = a - L for i in range ( n ): x = np . dot ( np . linalg . inv ( L ), b - np . dot ( U , x )) print ( str ( i ) . zfill ( 3 )), print ( x ) return x a = np . array ([[ 3. , 1. , - 1. ], [ 1. , 4. , 1. ], [ 1. , 2. , - 4. ]]) b = np . array ([ 6. , 8. , 9. ]) x = [ 0 , 0 , 0 ] n = 3 print ( \" \\n hasil dari perhitungan : \" , gauss ( a , b , x , n )) print ( \"hasil dari perhitungan : \" , solve ( a , b )) Hasil Output : 000 [ 2. 1.5 - 1. ] 001 [ 1.16666667 1.95833333 - 0.97916667 ] 002 [ 1.02083333 1.98958333 - 1. ] hasil dari perhitungan : [ 1.02083333 1.98958333 - 1. ] hasil dari perhitungan : [ 1. 2. - 1. ]","title":"Sistem Persamaan Linear"},{"location":"index2/#sistem_persamaan_linear","text":"Sistem persamaan linear merupakan sebuah sistem yang menghimpun beberapa persamaan linear yang memiliki banyak variabel. Penyelesaian sistem persamaan linear ini terdapat banyak cara yaitu eliminasi Gauss, metode Jacobi, dan metode Gauss Seidel.","title":"SISTEM PERSAMAAN LINEAR"},{"location":"index2/#eliminasi_gauss","text":"Eliminasi Gauss merupakan sebuah metode untuk menyelesaikan suatu sistem persamaan linear dengan mengubah menjadi matrix lalu membaginya menjadi segitiga bawah dan atas, untuk segitiga bawah harus bernilai nol dengan cara operasi baris elementer agar segera mendapatkan nilai variabelnya. \\[ \\begin{bmatrix} a_{11}, & a_{12},& a_{13},&\\ldots a_{1n} \\\\ 0 , & a_{22},& a_{23},&\\ldots a_{2n}\\\\ 0 , & 0,& a_{33},&\\ldots a_{3n} \\\\ \\ldots,& \\ldots ,& \\ldots ,& \\ldots \\\\ 0,& 0 ,& 0 ,& a_{nn} \\end{bmatrix} \\begin{bmatrix}x_{1} \\\\x_{2}\\\\x_{3}\\\\\\ldots\\\\x_{n}\\end{bmatrix}= \\begin{bmatrix}b_{1} \\\\b_{2}\\\\b_{3}\\\\\\ldots\\\\b_{n}\\end{bmatrix} \\] maka penyelesaian dapat dilakukan dengan cara : \\[ \\\\x_{n}=\\dfrac{b_{n}}{a_{n,n}} \\]","title":"Eliminasi Gauss"},{"location":"index2/#kode_python_eliminasi_gauss","text":"Program Python : import numpy as np n = int ( input ( \"Berapa baris dan kolom :\" )) m = n + 1 z = np . zeros ( n ) val = [ 0 ] * n for x in range ( n ): val [ x ] = [ 0.0 ] * m for i in range ( n ): for j in range ( n + 1 ): print (( \"[ {} ][ {} ]\" ) . format ( i , j ), end = ' ' ) y = float ( input ( \"Masukkan nilai :\" )) val [ i ][ j ] = y #eliminasi maju for i in range ( n ): for j in range ( i + 1 , n ): ratio = val [ j ][ i ] / val [ i ][ i ] for k in range ( n + 1 ): val [ j ][ k ] = val [ j ][ k ] - ratio * val [ i ][ k ] #eliminasi mundur z [ n - 1 ] = val [ n - 1 ][ n ] / val [ n - 1 ][ n - 1 ] for i in range ( n - 2 , - 1 , - 1 ): z [ i ] = val [ i ][ n ] for j in range ( i + 1 , n ): z [ i ] = z [ i ] - val [ i ][ j ] * z [ j ] z [ i ] = z [ i ] / val [ i ][ i ] print ( ' \\n hasil dari perhitungan : ' ) for i in range ( n ): print ( 'X %d = %0.2f ' % ( i , z [ i ]), end = ' \\t ' ) Hasil Output : Berapa baris dan kolom : 3 [ 0 ][ 0 ] Masukkan nilai : 3 [ 0 ][ 1 ] Masukkan nilai : 2 [ 0 ][ 2 ] Masukkan nilai : 5 [ 0 ][ 3 ] Masukkan nilai : 1 [ 1 ][ 0 ] Masukkan nilai : 2 [ 1 ][ 1 ] Masukkan nilai : 6 [ 1 ][ 2 ] Masukkan nilai : 3 [ 1 ][ 3 ] Masukkan nilai : 6 [ 2 ][ 0 ] Masukkan nilai : 3 [ 2 ][ 1 ] Masukkan nilai : 2 [ 2 ][ 2 ] Masukkan nilai : 7 [ 2 ][ 3 ] Masukkan nilai : 4 hasil dari perhitungan : X0 = - 3.00 X1 = 1.25 X2 = 1.50","title":"Kode python eliminasi Gauss"},{"location":"index2/#metode_jacobi","text":"Metode Jacobi merupakan sebuah metode untuk menemukan hasil dari sistem persamaan linear dengan cara menggunakan iterasi sebuah algoritma dan mengulangnya sampai bilangan tersebut diketemukan. Bila ada sebuah sistem persamaan linear \\[ \\\\ a_{11}x_{1}+ a_{12}x_{2}+\\ldots+ a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+ a_{22}x_{2}+\\ldots+ a_{2n}x_{n}=b_{2}\\\\ \\ldots+ \\ldots +\\ldots+\\ldots=\\ldots \\\\ a_{n1}x_{1}+ a_{n2}x_{2}+\\ldots+ a_{nn}x_{n}=b_{n} \\] persamaan ke-i dari persamaan di atas adalah \\[ a_{i1}x_{1}+ a_{i2}x_{2}+\\ldots+ a_{in}x_{n}=b_{i} \\\\dimana \\\\i = 1,2,3,\\ldots,n \\] dapat diekspresikan sebagai \\[ a_{ii}x_{i}+\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j} \\\\dengan \\\\i = 1,2,3,\\ldots,n \\] sehingga persamaan bisa terselesaikan dengan persamaan ke-i \\[ \\\\x_{i}=\\dfrac{b_{i}-\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j}}{a_{ii}} \\] dari penyelesaian tersebut dapat ditemukan sebuah algoritma metode Jacobi \\[ \\\\X_{i}^{\\left(k+1\\right) }=\\dfrac{b_{i}-\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j}^{\\left(k\\right) }}{a_{ii}},k=1,2,3,\\dots,n \\]","title":"Metode Jacobi"},{"location":"index2/#kode_python_metode_jacobi","text":"Program Python : import numpy as np k = 3 a = np . array ([[ 3. , 1. , - 1. ], [ 1. , 4. , 1. ], [ 1. , 2. , - 4. ]]) b = np . array ([ 6. , 8. , 9. ]) print ( \"sistem persamaan linear :\" ) for i in range ( a . shape [ 0 ]): row = [ \" {} *x {} \" . format ( a [ i , j ], j + 1 ) for j in range ( a . shape [ 1 ])] print ( \" + \" . join ( row ), \"=\" , b [ i ]) print () x = np . zeros_like ( b ) for it_count in range ( k ): print ( \"hasil sementara : \" , x ) x_new = np . zeros_like ( x ) for i in range ( a . shape [ 0 ]): s1 = np . dot ( a [ i , : i ], x [: i ]) s2 = np . dot ( a [ i , i + 1 :], x [ i + 1 :]) x_new [ i ] = ( b [ i ] - s1 - s2 ) / a [ i , i ] if np . allclose ( x , x_new , atol = 1e-10 , rtol = 0. ): break x = x_new print ( \"hasil akhir : \" , x ) error = np . dot ( a , x ) - b print ( \"error : \" , error ) Hasil Output : sistem persamaan linear : 3.0 * x1 + 1.0 * x2 + - 1.0 * x3 = 6.0 1.0 * x1 + 4.0 * x2 + 1.0 * x3 = 8.0 1.0 * x1 + 2.0 * x2 + - 4.0 * x3 = 9.0 hasil sementara : [ 0. 0. 0. ] hasil sementara : [ 2. 2. - 2.25 ] hasil sementara : [ 0.58333333 2.0625 - 0.75 ] hasil akhir : [ 1.0625 2.04166667 - 1.07291667 ] error : [ 0.30208333 0.15625 0.4375 ]","title":"Kode python metode Jacobi"},{"location":"index2/#metode_gauss_seidel","text":"Eliminasi Gauss Seidel merupakan pengembangan metode Jacobi dengan langsung menambahkan nilai terbaru ke dalam perhitungan atau iterasi selanjutnya. Bila ada sebuah sistem persamaan linear \\[ \\\\ a_{11}x_{1}+ a_{12}x_{2}+\\ldots+ a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+ a_{22}x_{2}+\\ldots+ a_{2n}x_{n}=b_{2}\\\\ \\ldots+ \\ldots +\\ldots+\\ldots=\\ldots \\\\ a_{n1}x_{1}+ a_{n2}x_{2}+\\ldots+ a_{nn}x_{n}=b_{n} \\] persamaan ke-i dari persamaan di atas adalah \\[ a_{i1}x_{1}+ a_{i2}x_{2}+\\ldots+ a_{in}x_{n}=b_{i} \\\\dimana \\\\i = 1,2,3,\\ldots,n \\] dapat diekspresikan sebagai \\[ a_{ii}x_{i}+\\sum ^{n}_{i=1,j\\neq i}a_{ij}x_{j} \\\\dengan \\\\i = 1,2,3,\\ldots,n \\] sebab dalam metode Gauss Seidel langsung menambahkan nilai terbaru maka persamaan ke-i dapat terselesaikan dengan cara \\[ \\\\x_{i}=\\dfrac{b_{i}- \\sum ^{i-1}_{j=1}a_{ij}x_{j}- \\sum ^{n}_{j=i+1}a_{ij}x_{j}}{a_{ii}} \\] dari penyelesaian tersebut dapat ditemukan sebuah algoritma metode Gauss Seidel \\[ \\\\x_{i}^{(k+1)}=\\dfrac{b_{i}- \\sum ^{i-1}_{j=1}a_{ij}x_{j}^{(k+1)}- \\sum ^{n}_{j=i+1}a_{ij}x_{j}^{(k)}}{a_{ii}}, \\\\k=1,2,3,\\ldots,n \\] nilai pendekatan iterasi ke-0 pada metode ini biasanya belum diketahui maka biasanya dapat ditentukan dengan \\[ X_{0}=0 \\]","title":"Metode Gauss Seidel"},{"location":"index2/#kode_python_metode_gauss_seidel","text":"Program Python : import numpy as np from scipy.linalg import solve def gauss ( a , b , x , n ): L = np . tril ( a ) U = a - L for i in range ( n ): x = np . dot ( np . linalg . inv ( L ), b - np . dot ( U , x )) print ( str ( i ) . zfill ( 3 )), print ( x ) return x a = np . array ([[ 3. , 1. , - 1. ], [ 1. , 4. , 1. ], [ 1. , 2. , - 4. ]]) b = np . array ([ 6. , 8. , 9. ]) x = [ 0 , 0 , 0 ] n = 3 print ( \" \\n hasil dari perhitungan : \" , gauss ( a , b , x , n )) print ( \"hasil dari perhitungan : \" , solve ( a , b )) Hasil Output : 000 [ 2. 1.5 - 1. ] 001 [ 1.16666667 1.95833333 - 0.97916667 ] 002 [ 1.02083333 1.98958333 - 1. ] hasil dari perhitungan : [ 1.02083333 1.98958333 - 1. ] hasil dari perhitungan : [ 1. 2. - 1. ]","title":"Kode python metode Gauss Seidel"},{"location":"index3/","text":"PERSAMAAN DIFERENSIAL BIASA \u00b6 Persamaan diferensial biasa merupakan sebuah persamaan yang memiliki satu atau lebih variabel bebas dan tak bebas dari sebuah turunan fungsi. Penyelesaian persamaan ini bisa menggunakan metode Taylor orde satu (metode Euler), metode Taylor orde dua, metode Taylor orde tiga, metode Taylor orde tinggi, dan metode Taylor tingkat tinggi. Metode Euler \u00b6 Metode Euler merupakan metode nilai y baru diperkirakan berdasarkan slope, sama dengan derivatif pertama di titik x, untuk mengekstrapolasikan nilai y lama secara linear dalam selang h ke nilai y baru. Algoritma Metode Euler \u00b6 Tentukan titik awal Xo dan Yo Tentukan jumlah iterasi n dan langkah h yang akan digunakan Lakukan integrasi menggunakan Persamaan di bawah ini Persamaan Euler \\\\y_{i+1}=y_{i}+f(x_{i},y_{i})h Kode python metode Euler \u00b6 Program Python : import math # fungsi bisa diganti sesuai soal def numeric ( x , y , h ): return y + (( x + y ) * h ) x = 0 y = 1 h = 0.5 interval = 2 while x <= interval : res = numeric ( x , y , h ) print ( \"x = {} \" . format ( x )) print ( \"y = {} \\n \" . format ( res )) y = res x += h Hasil Output : x = 0 y = 1.5 x = 0.5 y = 2.5 x = 1.0 y = 4.25 x = 1.5 y = 7.125 x = 2.0 y = 11.6875","title":"Persamaan Diferensial Biasa"},{"location":"index3/#persamaan_diferensial_biasa","text":"Persamaan diferensial biasa merupakan sebuah persamaan yang memiliki satu atau lebih variabel bebas dan tak bebas dari sebuah turunan fungsi. Penyelesaian persamaan ini bisa menggunakan metode Taylor orde satu (metode Euler), metode Taylor orde dua, metode Taylor orde tiga, metode Taylor orde tinggi, dan metode Taylor tingkat tinggi.","title":"PERSAMAAN DIFERENSIAL BIASA"},{"location":"index3/#metode_euler","text":"Metode Euler merupakan metode nilai y baru diperkirakan berdasarkan slope, sama dengan derivatif pertama di titik x, untuk mengekstrapolasikan nilai y lama secara linear dalam selang h ke nilai y baru.","title":"Metode Euler"},{"location":"index3/#algoritma_metode_euler","text":"Tentukan titik awal Xo dan Yo Tentukan jumlah iterasi n dan langkah h yang akan digunakan Lakukan integrasi menggunakan Persamaan di bawah ini Persamaan Euler \\\\y_{i+1}=y_{i}+f(x_{i},y_{i})h","title":"Algoritma Metode Euler"},{"location":"index3/#kode_python_metode_euler","text":"Program Python : import math # fungsi bisa diganti sesuai soal def numeric ( x , y , h ): return y + (( x + y ) * h ) x = 0 y = 1 h = 0.5 interval = 2 while x <= interval : res = numeric ( x , y , h ) print ( \"x = {} \" . format ( x )) print ( \"y = {} \\n \" . format ( res )) y = res x += h Hasil Output : x = 0 y = 1.5 x = 0.5 y = 2.5 x = 1.0 y = 4.25 x = 1.5 y = 7.125 x = 2.0 y = 11.6875","title":"Kode python metode Euler"}]}